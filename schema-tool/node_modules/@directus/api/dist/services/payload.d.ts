import type { AbstractServiceOptions, Accountability, Aggregate, DefaultOverwrite, FieldOverview, Item, MutationOptions, PayloadAction, PayloadServiceProcessRelationResult, PrimaryKey, SchemaOverview } from '@directus/types';
import type { Knex } from 'knex';
import type { Helpers } from '../database/helpers/index.js';
type Transformers = {
    [type: string]: (context: {
        action: PayloadAction;
        value: any;
        payload: Partial<Item>;
        accountability: Accountability | null;
        specials: string[];
        helpers: Helpers;
        overwriteDefaults: DefaultOverwrite | undefined;
    }) => Promise<any>;
};
/**
 * Process a given payload for a collection to ensure the special fields (hash, uuid, date etc) are
 * handled correctly.
 */
export declare class PayloadService {
    accountability: Accountability | null;
    knex: Knex;
    helpers: Helpers;
    collection: string;
    schema: SchemaOverview;
    nested: string[];
    overwriteDefaults: DefaultOverwrite | undefined;
    constructor(collection: string, options: AbstractServiceOptions & {
        overwriteDefaults?: DefaultOverwrite | undefined;
    });
    transformers: Transformers;
    processValues(action: PayloadAction, payloads: Partial<Item>[]): Promise<Partial<Item>[]>;
    processValues(action: PayloadAction, payload: Partial<Item>): Promise<Partial<Item>>;
    processValues(action: PayloadAction, payloads: Partial<Item>[], aliasMap: Record<string, string>, aggregate: Aggregate): Promise<Partial<Item>[]>;
    processValues(action: PayloadAction, payload: Partial<Item>, aliasMap: Record<string, string>, aggregate: Aggregate): Promise<Partial<Item>>;
    processAggregates(payload: Partial<Item>[], aggregate?: Aggregate): void;
    processField(field: SchemaOverview['collections'][string]['fields'][string], payload: Partial<Item>, action: PayloadAction, accountability: Accountability | null): Promise<any>;
    /**
     * Native geometries are stored in custom binary format. We need to insert them with
     * the function st_geomfromtext. For this to work, that function call must not be
     * escaped. It's therefore placed as a Knex.Raw object in the payload. Thus the need
     * to check if the value is a raw instance before stringifying it in the next step.
     */
    processGeometries<T extends Partial<Record<string, any>>[]>(fieldEntries: [string, FieldOverview][], payloads: T, action: PayloadAction): T;
    /**
     * Knex returns `datetime` and `date` columns as Date.. This is wrong for date / datetime, as those
     * shouldn't return with time / timezone info respectively
     */
    processDates(fieldEntries: [string, FieldOverview][], payloads: Partial<Record<string, any>>[], action: PayloadAction, aliasMap?: Record<string, string>, aggregate?: Aggregate): Partial<Record<string, any>>[];
    /**
     * Recursively save/update all nested related Any-to-One items
     */
    processA2O(data: Partial<Item>, opts?: MutationOptions): Promise<PayloadServiceProcessRelationResult & {
        payload: Partial<Item>;
    }>;
    /**
     * Save/update all nested related m2o items inside the payload
     */
    processM2O(data: Partial<Item>, opts?: MutationOptions): Promise<PayloadServiceProcessRelationResult & {
        payload: Partial<Item>;
    }>;
    /**
     * Recursively save/update all nested related o2m items
     */
    processO2M(data: Partial<Item>, parent: PrimaryKey, opts?: MutationOptions): Promise<PayloadServiceProcessRelationResult>;
    /**
     * Transforms the input partial payload to match the output structure, to have consistency
     * between delta and data
     */
    prepareDelta(delta: Partial<Item>): Promise<string | null>;
}
export {};
